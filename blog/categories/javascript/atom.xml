<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | ZePaG's blog, As if you cared...]]></title>
  <link href="http://zepag.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://zepag.github.io/"/>
  <updated>2014-05-11T15:39:33+02:00</updated>
  <id>http://zepag.github.io/</id>
  <author>
    <name><![CDATA[Pierre-Antoine Grégoire]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Javascript: The Black Beast of Aaaaarrrrgggghhhh (Part 3)]]></title>
    <link href="http://zepag.github.io/blog/2008/09/11/javascript-black-beast-of_11/"/>
    <updated>2008-09-11T00:00:00+02:00</updated>
    <id>http://zepag.github.io/blog/2008/09/11/javascript-black-beast-of_11</id>
    <content type="html"><![CDATA[<div class='post'>
With this third part, we're starting to dig into the interesting bits: modules or how to manage the scope of your code.<br /><b>EDIT: Modules are delayed to a further blog post :p</b><br /><br />But before this, let's talk about something else as an appetizer.<br /><br /><span style="font-size:140%;">Boolean(false) is truthy</span><br /><br />Javascript shares the burden of C-Style truthy/falsy concept. These are non-boolean expressions that can be treated as a boolean value. It is both powerful and very dangerous, because (once again) it presumes the developer already knows everything about the language's subtleties.<br /><br />So let's first list the falsy elements, all the rest being truthy: <b>0</b>,<b>false</b> (of course), <b>empty string: "" or ''</b>, <b>null</b><br /><br />Presented this way, it seems quite simple... though there are some quirks due to where and how you're going to take advantage of these evaluations.<br />For example, 0 evaluates to false, while '0' evaluates to true (non-empty string). This sounds easy once again, but can be tricky when you receive a variable value and just test it this way: <i>if(myVar){...}</i>. It can lead to very counter-intuitive tests...<br /><br /><pre name="code" class="javascript">var myVar=new Boolean(false);<br />if(myVar){<br />    alert("true");<br />// Never use alert() in real applications, it blocks all javascript execution in all tabs of a browser until you close it.<br />}<br /></pre>This is one example of code where one should stop thinking in another language's logic (Java or C# for example). <i>new Boolean(false)</i> is an object, and an object is always truthy, ending up with an alert popup showing "true".<br />Though if you replace <i>if(myVar)...</i> with <i>if(myVar==true)...</i> the test will end up as expected, with nothing happening.<br />This can be confusing... I agree, and it did confuse me. Until I heard about the === operator. In javascript, == was designed as a tolerant operator, which accepts 1=='1' as a true assertion. So in later versions of javascript (when war between Netscape and IE was raging a while ago), a new === operator was introduced for a comparison of references. This operator is the one you'd want to use in order to be sure that an object is the same as another.<br /><br /><br />Oh and by the way, this may not be the last of my posts about javascript... so I'm going to drop in some of the references I used, in order not to forget them, and leave you my dear only reader with something else to read ;).<br /><br /><a href="http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting">a Blog post about Truthy falsy</a><br /><a href="http://javascript.crockford.com">The source of all javascript wisdom ;): Sir Crockford.</a></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript: The Black Beast of Aaaaarrrrgggghhhh (Part 2)]]></title>
    <link href="http://zepag.github.io/blog/2008/09/09/javascript-black-beast-of/"/>
    <updated>2008-09-09T00:00:00+02:00</updated>
    <id>http://zepag.github.io/blog/2008/09/09/javascript-black-beast-of</id>
    <content type="html"><![CDATA[<div class='post'>
First part of this "series" introduced basic concepts of the javascript language.<br />This new entry will introduce the functional nature of javascript.<br /><br /><br />In javascript, there is (almost) no limit to where a function can be defined (as opposed to a class language like java for example). It doesn't even have to have a name and can be defined anonymously. A function can also be created as a local variable in another function's body (inner function).<br /><br />Functions represent the real power of javascript. Not understanding them means not understanding javascript.<br /><br />Javascript uses functions all around. Functions are <b>objects</b>, and as such can be passed as parameters to other functions, or returned from other function's invocation.<br /><br />As there is no proper class, one may think that there is no such thing as a method. This is not really the case. In fact one may call "method" any function defined as an attribute to an object.<br /><br /><pre name="code" class="javascript"><br />var myObj={<br />    myAttribute:"valueOfAttribute",<br />    myMethod: function(){<br />        if(console){<br />            console.log("hello universe");<br />        }<br />    }<br />};<br /></pre><br />Functions are (almost) always stored in a variable of some kind, and can even be stored in local variables. <br />In fact, defining a function in an html script tag like this:<br /><pre name="code" class="javascript"><br />function myFunction(){<br />    if(console){<br />        console.log("hello universe");<br />    }<br />}<br /></pre><br />... is completely equivalent to the following definition:<br /><pre name="code" class="javascript"><br />var myFunction=function(){<br />    if(console){<br />        console.log("hello universe");<br />    }<br />};</pre><br />This form is much clearer, as there is now no ambiguity about its object nature and about where it is stored... at least when you understand another little thing...<br /><br /><span style="font-size:140%;">The global object:</span><br /><b><br />In javascript, if you don't use the var keyword, or if you define variables in no specific construct </b>(e.g. not in a function, an object, an array, or any conditional construct like if, for...etc), <b>variables are defined as attributes to the global object. The global object depends on the runtime you are coding for. In a browser, this global object is the <u>window</u> object.</b><br /><br />Now read my lips: <b>"GLOBAL OBJECT IS EVIL"</b>. This global space is the worst place for the definition of your code. Oh, and by the way, variables defined without the var keyword are <u>always</u> defined as attributes of this global object, regardless of their scope.<br /><br />So, what's the solution to this?<br /><br />Create your own <b>namespace</b>! <br /><br />You'll often ear about namespaces in the javascript world. In fact, this just refers to a container (javascript object) containing all the objects, states  and functions needed for your code. This allows you not to pollute the global namespace (though this is not sufficient to disallow access to private states, wait for 3rd part of this blog series on the module pattern).<br /><br />YahooUI started this trend with the YAHOO namespace. Other frameworks have also created their namespace(s) (Ext.* for ExtJS, dojo.* for Dojo, a global "$" or "jQuery" object for JQuery, Prototype.* for prototype, etc...). This allows the use of various "libraries" that are less likely to collide, or at least in a more controlled fashion.<br /><br />As demonstrated in previous blog entry, creating an object, and therefore a namespace, is very easy:<br /><pre name="code" class="javascript"><br />var MyNamespace={};<br /></pre><br />And now adding elements to this namespace is as easy as invoking<br /><pre name="code" class="javascript"><br />MyNamespace.myElement="element's value";<br />MyNamespace.myFunction=function(){<br />    if(console){<br />        console.log("hello universe");<br />    }<br />}<br /></pre><br />You can see that the function we mentionned before is now defined in a custom object (namespace) and that we can therefore invoke:<br /><pre name="code" class="javascript"><br />MyNamespace.myFunction();<br /></pre><br />This exemple is of course very simplistic, and not very secure. In fact any code can replace these states, because objects don't have scopes! Let's detail this mind-boggling fact.<br /><br /><span style="font-size:140%;">Objects don't have scopes, functions do</span><br /><br />When you create an object, its state is public and accessible to any code that has access to the object in the first place. Any other code can add, remove and update entries from this container.<br /><br />The only mean of reducing scope in javascript is functions. Hence the functional nature of the language.<br /><br />Whatever is defined in a function is only accessible to this function and to any other construct defined in this function. <b>The only visible thing from a given function, is the result from its invocation.</b><br /><br /><pre name="code" class="javascript"><br />var myFunction=function(){<br />    var myVar="hello universe";<br />    // let's create an object accessing this 'private' state<br />    var result={<br />        myPublicVar:myVar+", I'm a public variable"<br />    };<br />    return result;<br />}<br />// next line will output undefined, because myVar is local to the function only.<br />console.log(myFunction.myVar);<br />// the next one will output 'hello universe, I'm a public variable', because the object returned by the invocation has access to the context of the function it was defined in (by the way, this is what is usually called access through a closure).<br />console.log(myFunction().myPublicVar);<br /></pre><br />As you may have noticed, and as a little conclusion to this post, one thing you really have to be careful with when reading or writing javascript code, is the presence of <b>()</b>. Whether a function is invoked or not is really important. This will determine whether you are left with the function object itself, ready to be invoked at will, or with the result from this function's invocation. <br /><br />This is it for the moment. next entry will deal with the constructors (and the other ways to invoke a function), the concept of module, the truthy/falsy idea, and also give credit to the reference(s) used to build this little introduction to javascript ;).</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript: The Black Beast of Aaaaarrrrgggghhhh (Part 1)]]></title>
    <link href="http://zepag.github.io/blog/2008/06/21/javascript-black-beast-of/"/>
    <updated>2008-06-21T00:00:00+02:00</updated>
    <id>http://zepag.github.io/blog/2008/06/21/javascript-black-beast-of</id>
    <content type="html"><![CDATA[<div class='post'>
I've really wanted (and still want) to have a grasp on how Javascript should be coded <span style="font-weight: bold;">the Javascript way</span>.<br /><br />As a regular <span style="font-weight: bold;">Java</span> (and occasionally other languages) developer, I've sometimes used javascript with this constant sense of weirdness on the edges, and without being able to grasp the concepts in it.<br />In fact, the browsers' DOM and the history of the Javascript implementations in browsers contributed to this fuzziness (as we'll see later).<br /><br /><span style="font-size:140%;">Basic concepts:</span><br /><br />Javascript has very little to do with Java. In fact its name only contains java for marketting purposes of that time. Javascript is a language from the C family like java and uses a lot of the same operators and syntax.<br /><br />This can be confusing, because Java and Javascript are indeed <span style="font-weight: bold;">very</span> different.<br /><br />While <span style="font-style:italic;">Java</span> is based on classes and inheritance <span style="font-style:italic;">between classes</span>, <span style="font-weight:bold;">Javascript</span> is based on objects and inheritance between <span style="font-weight:bold;">objects</span>.<br />Javascript is also a prototype-based language (which is I think the hardest part to grasp...).<br /><br />This may sound a bit abstract, but one cannot hope coding proper javascript without at least understanding these concepts.<br /><br /><span style="font-size:140%;">A little pause</span><br /><br />Before we start explaining the previous concepts, you must be aware that Javascript's history has been very clumsy to say the least.<br />Some good decisions were taken, and some very bad ones.<br /><br />Most of the bad decisions were made during the browsers' war (Netscape vs Internet Explorer) with a purpose to attract developers from Java/C++ or VBScript for example.<br /><br />These bad decisions leave strange reserved words in the language (like 'abstract' or 'interface' which are never used,) that should never be used or even cannot be used, and constructs that come from other worlds.<br /><br />If you add to that the incompatibilities of APIs and models between browsers, it's easy to understand why Javascript is still often considered as a toy language.<br /><br />So don't be surprised by the number of things that should not be used or touched in Javascript.<br /><br /><span style="font-size:140%;">Javascript is not a toy language, nor a poor OO language.</span><br /><br />In fact, in a way, Javascript is more OO than Java is ;).<br />In Javascript (almost) everything is object (think instances, forget about classes!).<br /><br />Here's a list of the things that are NOT objects in Javascript:<br /><ul><br /><li>numbers</li><br /><li>strings</li><br /><li>booleans</li><br /><li>null</li><br /><li>undefined</li><br /></ul><br /><br /><span style="font-weight: bold;">Everything else is objects.</span><br />Yes, everything.<br />Keep that in mind, and remember (again) that I said Object (instance), not Class.<br /><br />One really clever thing that was done in javascript is the <span style="font-weight: bold;">merging of Objects and Hashtable</span>.<br />A new Object is an empty container of key/value pairs.<br /><br />For example, one can create an object using:<br /><br /><pre name="code" class="javascript"><br />var myObject={};<br /></pre><br /><br />As Javascript is loosely typed, there is no class definition. You just created an Object with nothing in it.<br /><br /><pre name="code" class="javascript"><br />var user={<br />    firstname="Pierre-Antoine"<br />    ,'lastname'='Grégoire'<br />    ,age=31<br />};<br /></pre><br /><br />As you can see, it's quite easy to create an object using key/values.<br />As you also probably noticed, keys can be String, therefore allowing access to members in two ways:<br /><ul><br /><li>using the dot notation: <span style="font-style: italic;">user.firstName</span> </li><br /><li>using the subscript notation: <span style="font-style: italic;">user["firstname"]</span></li><br /></ul><br /><br />This is it for this first short part. Next blog entry will introduce the functional nature of Javascript.</div>


<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>David Dossot</div>
<div class='content'>
Excellent idea: debunking JavaScript's myths and prejudices is really important, as this language now runs in the JVM directly.</div>
</div>
</div>

]]></content>
  </entry>
  
</feed>
